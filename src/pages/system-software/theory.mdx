---
layout: ../../layouts/TheoryLayout.astro
title: Системное программное обеспечение
icon: console
subheader: Кафедра математического обеспечения и стандартизации ИТ
links: system-software
activeLinkIdx: 0
---

#### 1. Загрузчик операционной системы. Определение и задачи.

**Загрузчик операционной системы** — системное программное обеспечение, обеспечивающее загрузку операционной системы непосредственно после включения компьютера и начальной загрузки.

**Задачи** загрузчика:

* обеспечивает необходимые средства для диалога с пользователем компьютера (например, загрузчик позволяет выбрать операционную систему для загрузки);
* приводит аппаратуру компьютера в состояние, необходимое для старта ядра операционной системы (например, на не-x86 архитектурах перед запуском ядра загрузчик должен правильно настроить виртуальную память);
* загружает ядро операционной системы (Ntoskrnl.exe в случае MS Windows) в ОЗУ. Загрузка ядра операционной системы не обязательно происходит с жесткого диска. Загрузчик может получать ядро по сети. Ядро может храниться в ПЗУ или загружаться через последовательные интерфейсы (это может пригодиться на ранней стадии отладки создаваемой компьютерной системы);
* формирует параметры, передаваемые ядру операционной системы (например, ядру Linux передаются параметры, указывающие способ подключения корневой файловой системы);
* передаёт управление ядру операционной системы.

#### 2. Объекты ядра операционной системы. Процессы, файлы, события, потоки.

**Процесс** — это совокупность набора исполняющихся команд, ассоциированных с ними ресурсов и текущего момента их выполнения.

**Файл** — именованная область данных на носителе информации, используемая как базовый объект взаимодействия с данными в операционных системах.

**События** — это наиболее примитивные объекты ядра. Они предназначены для информирования одного потока другим об окончании какой-либо операции.

**Поток** (thread) — это сущность операционной системы, процесс выполнения на процессоре набора инструкций, точнее говоря программного кода. Общее назначение потоков — параллельное выполнение на процессоре двух или более различных задач.

#### 3. Объекты ядра операционной системы. Семафоры и мьютексы.

**Семафоры** — это объекты ядра, которые используются для учёта ресурсов. Они представляют собой целую переменную в пространстве ядра, доступ к которой после инициализации может осуществляться через две атомарные операции: wait и signal.

**Мьютексы** — это объекты ядра, которые используются для синхронизации. Они проще семафоров, так как регулируют доступ к единственному ресурсу и не содержат счётчиков. По существу они ведут себя как критические секции, но могут синхронизировать доступ потоков разных процессов.

#### 4. Командный процессор. Оболочка операционной системы.

**Командный** **процессор** — оболочка операционной системы, обеспечивающая интерфейс командной строки и выполняющая текстовые команды пользователя.

Например, *PowerShell* в Windows, *bash, zsh* в Unix.

#### 5. Системный вызов. Понятие, применение в составе ОС Linux.

**Системный вызов** (system call) — обращение прикладной программы к ядру операционной системы для выполнения какой-либо операции.

В основном взаимодействие пользовательских программ и операционной системы касается первой функции — взять, к примеру, операции с файлами: создание, запись, чтение и удаление. А управление ресурсами компьютера проходит большей частью незаметно для пользователей и осуществляется в автоматическом режиме. Так что интерфейс между пользовательскими программами и операционной системой строится в основном на абстракциях. Имеющиеся в интерфейсе системные вызовы варьируются в зависимости от используемой операционной системы.

#### 6. Архитектурные особенности ОС Unix.

1. Системы Unix используют централизованное ядро операционной системы, которое управляет системными и процессуальными действиями.
2. Всё неядерное программное обеспечение организовано в отдельные процессы, управляемые ядром.
3. Системы Unix преимущественно многозадачны: несколько процессов могут выполняться одновременно или в течение небольших временных интервалов.
4. Файлы хранятся на диске в иерархической файловой системе с единственным верхним расположением во всей системе.
5. Устройства и некоторые типы коммуникаций между процессами управляются и отображаются в виде файлов или псевдофайлов в иерархии файловой системы.

#### 7. Зависимости пакетов. Виды зависимостей.

**Зависимости пакета** — это набор сведений, описывающих требования к наличию других программных пакетов и иных условий, необходимых данному пакету для функционирования.

**Различают следующие виды зависимостей:**

1. **Сборочные зависимости** — набор пакетов, которые должны быть доступны во время распаковки, конфигурирования, компиляции и установки пакета.
2. **Зависимости стадии выполнения** — набор пакетов, которые должны быть доступны в процессе выполнения программы.

#### 8. Пакетный менеджер APT. Состав, задачи.

**APT (Advanced Packaging Tool) — это система управления пакетами в Linux.**

Она включает в себя следующие утилиты:

1. **apt-cache** — манипулирует кэшем доступных пакетов.
2. **apt-cdrom** — позволяет добавить CD/DVD-диск в качестве источника пакетов.
3. **apt-config** — читает значения опций, заданных в конфигурационном файле.
4. **apt-extracttemplates** — извлекает конфигурационные файлы DebConf из пакетов.
5. **apt-ftparchive** — создаёт индексные файлы.
6. **apt-get** — устанавливает, удаляет, обновляет список пакетов и сами пакеты.
7. **apt-key** — управляет ключами аутентификации.
8. **apt-secure** — проверяет подлинность цифровой подписи пакетов.
9. **apt-sortpkgs** — сортирует индексные файлы.

#### 9. Пакетный репозиторий. Разделы пакетного репозитория.

**Пакетный репозиторий** — централизованное хранилище пакетов.

Разделы пакетного репозитория в Ubuntu:

- **main** - также, как и в Debian содержит свободные пакеты, поддерживаемые компанией Canonical;
- **restricted** - несвободное ПО, поддерживаемое Canonical;
- **universe** - свободное ПО, поддерживаемое сообществом;
- **multiverse** - несвободное ПО, поддерживаемое сообществом.

#### 10. Классы выпусков дистрибутивов Debian.

Существует три класса выпусков Debian:

* **Стабильный** — содержит последнюю официально выпущенную версию дистрибутива Debian;
* **Тестируемый** — содержит пакеты, которые ещё не вошли в стабильный выпуск, но ожидается, что они туда попадут;
* **Нестабильный** — дистрибутив, находящийся в активной разработке в данный момент.

#### 11. Понятие среды окружения. Объекты среды окружения.

**Среда окружения** — совокупность значений системных переменных, путей, открытых файловых дескрипторов и других ресурсов операционной системы, передаваемые процессу (программе) при его запуске.

**К объектам среды окружения обычно относят:**

- системные переменные;
- текущие пути на различных дисках;
- точка монтирования каталогов;
- связь стандартных потоков ввода-вывода с файловыми хэндлерами или устройствами;
- ограничения на количество одновременно открытых файлов, стеков и т. д.;
- набор прав;
- дисковые квоты, ограничение на максимальный объём оперативной памяти, загрузки процессоров и т. д.;
- значения показателей использования ресурсов, получаемые от родительского процесса (на некоторых системах).

#### 12. Основные переменные среды окружения ОС Linux.

- `SHELL` – описание оболочки, где интерпретируются вводимые команды – обычно это bash, но пользователь вправе указать иной способ;
- `TERM` – указание вида терминала, используемого при старте;
- `USER` – наименование аккаунта, который использовался для входа в систему;
- `PWD` – рабочая папка;
- `OLDPWD` – папка, используемая ранее (необходима для возможности вернуться в нее при помощи cd-);
- `LS_COLORS` – коды, выделяющие различными цветами файлы в соответствии с их типом (для удобства восприятия больших объемов информации при беглом осмотре);
- `MAIL` – путь, где размещен почтовый ящик активного аккаунта;
- `PATH` – перечень папок, где система ищет команды;
- `LANG` – поддерживаемый язык;
- `HOME` – домашняя папка пользователя;
- `_` – команда, которую выполнила система последней.

#### 13. Понятие системного окружения (яруса).

**Системное окружение** — компьютерная система, в которой компьютерная программа или компонент программного обеспечения развёртывается и выполняется.

Окружения могут существенно отличаться в размерах: **development** окружение это обычно рабочая станция отдельного разработчика, в то время как **production** окружение может быть сетью множества географически разнесённых машин в случае с дата-центрами, или виртуальными машинами в случае с облачными решениями.

#### 14. Определение понятия «виртуализация». Задачи виртуализации.

**Виртуализация** — это построение вычислительной среды, в которой на базе одних и тех же аппаратных ресурсов работает множество изолированных друг от друга виртуальных машин.

#### 15. Определение понятия «виртуализация». Преимущества виртуализации.

1. **Экономичность.** Избавляет компанию от необходимости покупки дополнительных серверов, предназначенных для решения отдельных задач.
2. **Гибкость.** При увеличении нагрузки на виртуальные машины можно масштабировать ресурсы, чтобы избежать их исчерпания.
3. **Надёжная изоляция.** Сбои и заражения одной виртуальной машины не отражаются на работоспособности других, расположенных на том же сервере.
4. **Управление версиями.** Снимки виртуальной машины позволяют отменить неудачные изменения и быстро вернуться к первоначальному состоянию системы.
5. **Контроль над ресурсами.** Виртуализация позволяет распределять вычислительные мощности между виртуальными машинами.

#### 16. Определение понятия «виртуализация». Недостатки виртуализации.

Недостатки виртуализации:

1. **Снижение производительности**: виртуальные машины могут снижать производительность по сравнению с работой на физическом оборудовании.
2. **Потребление ресурсов**: виртуализация требует дополнительных ресурсов, таких как оперативная память и процессорное время, что может замедлить работу других приложений на компьютере.
3. **Сложность настройки и управления**: настройка и управление виртуальными машинами может быть сложным процессом для неопытных пользователей.
4. **Безопасность**: виртуализация может создавать дополнительные точки отказа и уязвимости в системе безопасности, особенно если не используются надёжные средства защиты.

#### 17. Контейнеры приложений.

**Виртуальный контейнер приложения** — это изолирующая прослойка между программой и операционной системой.

Он обеспечивает:

- среду выполнения, отделённую от операционной системы и других приложений;
- управление параметрами рабочей среды приложения;
- упрощённый перенос приложения с одного компьютера на другой.

Контейнеры приложений применяются в прикладном программировании и строительстве высоконагруженных информационных систем.

#### 18. Регулярные выражения. Определение, задачи, механизмы реализации.

Регулярные выражения *(regex)* — это формальный язык, используемый в компьютерных программах для поиска и манипуляций с подстроками в тексте. Они основаны на использовании метасимволов (символов-джокеров) и задаются строкой-образцом (шаблоном или маской), состоящей из символов и метасимволов.

Регулярные выражения используются для поиска, проверки наличия искомого образца в тексте, определения подстрок и групп символов, соответствующих отдельным частям образца. Также они применяются для замены текста, когда результат работы представляет собой новую текстовую строку с удалением найденных подстрок и заменой их на строки замены.

**Пример регулярного выражения:**

```javascript
/^[a-zа-яё0-9]{3,}$/i
```

#### 19. Непрерывная доставка. Определение. Основные элементы.

Непрерывная доставка *(Continuous Delivery, CD)* — это подход к разработке программного обеспечения, при котором программное обеспечение создаётся короткими итерациями, обеспечивая стабильность и возможность передачи в эксплуатацию в любое время. Основные элементы непрерывной доставки включают:

1. **Короткие итерации разработки**: создание и выпуск программного обеспечения короткими циклами, что позволяет быстро выявлять и исправлять ошибки.
2. **Стабильность кода**: обеспечение стабильности кода и минимизация рисков, связанных с внесением изменений.
3. **Автоматизация сборки и тестирования**: использование инструментов автоматизации для упрощения процессов сборки, тестирования и развёртывания программного обеспечения.
4. **Непрерывное интегрирование**: интеграция новых изменений в основную кодовую базу после каждого коммита.
5. **Непрерывное тестирование**: проведение автоматизированных тестов для проверки качества кода перед каждым выпуском.
6. **Непрерывное развёртывание**: автоматическое развёртывание новых версий программного обеспечения в тестовой и продуктивной средах без участия человека.

#### 20. Непрерывная интеграция. Определение. Основные элементы.

Непрерывная интеграция *(Continuous Integration, CI)* — это методология разработки программного обеспечения, которая предполагает регулярное внесение изменений в общую кодовую базу проекта. Основные элементы непрерывной интеграции включают:

1. Источник или система контроля версий с единой кодовой базой, включая файлы исходного кода, библиотеки, файлы конфигурации и скрипты.
2. Автоматизированные билд-скрипты для создания исполняемых файлов из исходного кода.
3. Автоматизированные тесты для проверки поведения кода и обнаружения возможных ошибок.
4. Инфраструктура для выполнения сборки и тестов, такая как TeamCity.

#### 21. Образ контейнера. Определение. Два состояния контейнера.

**Образ контейнера** — это файл, содержащий информацию о конфигурации и инструкции для создания и запуска контейнера.

Он может находиться в одном из двух состояний: работающем и неработающем. В неработающем состоянии образ контейнера представляет собой файл или набор файлов, хранящихся на диске.

#### 22. Контейнерный движок. Задачи контейнерного движка.

**Контейнерный движок** позволяет запускать несколько приложений на одной виртуальной машине, поэтому нет необходимости покупать разные лицензии.

Вот некоторые задачи, для которых используют контейнерный движок:

1. Упрощение процесса развёртывания приложений.
2. Тестирование кода и исправление ошибок в нём.
3. Работа с приложением через другую ОС.
4. Одновременная работа с несколькими программами, чтобы снизить нагрузку на своё железо.
5. Адаптация софта для более современной среды.

#### 23. Контейнерный хост. Определение. Задачи.

**Контейнерный хост** — это система, на которой выполняются контейнеризованные процессы, называемые контейнерами.

Задачи контейнерного хоста включают:
* Обеспечение выполнения контейнеров, созданных из образов, хранящихся в реестре.
* Управление жизненным циклом контейнеров, включая запуск, остановку, удаление и перемещение.
* Изоляция контейнеров друг от друга и от операционной системы для обеспечения безопасности и стабильности работы.
* Обеспечение доступа к ресурсам хоста, таким как процессор, память, диски и сетевые интерфейсы, для корректной работы контейнеров.
* Поддержка различных технологий и инструментов, таких как Docker, CRI-O, LXC и другие, для создания и управления контейнерами.

#### 24. Сервер реестра. Определение. Задачи.

**Сервер реестра** — это компонент операционной системы, который хранит информацию о настройках аппаратного обеспечения, программного обеспечения, профилях пользователей и предустановках.

Задачи сервера реестра включают:
1. Связь DDE и OLE-объектов.
2. Хранение конфигурации системы.
3. Предоставление доступа к информации о зарегистрированных типах файлов и объектах COM и ActiveX.
4. Хранение параметров по умолчанию для всех пользователей локального компьютера и текущих пользователей.
5. Обеспечение обратной совместимости с предыдущими версиями операционных систем.

#### 25. Определение системы докер. Докер-демон и докер–клиент.

**Docker** — это программное обеспечение для автоматизации процессов развёртывания и управления приложениями в специальной среде виртуализации.

**Docker-демон** — это процесс, который работает на хост-машине и управляет всей инфраструктурой Docker, создаёт, запускает, останавливает и удаляет контейнеры, а также предоставляет интерфейс для взаимодействия с ними.

**Docker-клиент** — это интерфейс командной строки, который используется для управления Docker-демоном и для создания и развёртывания контейнеров.

#### 26. Определение системы докер. Докер-образ и докер–реестр.

**Docker-образ** — это коллекция программного обеспечения, которая должна запускаться как контейнер.

**Docker-реестр** — это место для хранения и выгрузки образов, масштабируемое серверное приложение без учёта состояний.

#### 27. Пространство имен в системе докер. Основные пространства имен.

**Пространство имён** (namespaces) в Docker — это технология, используемая для организации изолированных рабочих пространств, называемых контейнерами.

Docker использует следующие основные пространства имён:

1. PID (Process Identifier) — для изоляции процессов.
2. NET (Network) — для управления сетевыми интерфейсами.
3. IPC (Inter-Process Communication) — для управления ресурсами межпроцессного взаимодействия.
4. MNT (Mount Point) — для управления точками монтирования.
5. UTS (Unix Time Sharing) — для изоляции ядра и контроля генерации версий.

#### 28. Конфигурационное управление. Цели и задачи конфигурационного управления.

**Конфигурационное управление** (англ. software configuration management, SCM) в программной инженерии — комплекс методов, направленных на систематический учёт изменений, вносимых разработчиками в программный продукт в процессе его разработки и сопровождения, сохранение целостности системы после изменений, предотвращение нежелательных и непредсказуемых эффектов, формализацию процесса внесения изменений.

Цели конфигурационного управления:
* *контроль*: отслеживание изменений в контролируемых объектах и соблюдение процесса разработки;
* *управление*: автоматическая идентификация изменений в ходе жизненного цикла ПО, простота модификации и сопровождения ПО.

Задачи конфигурационного управления:
* *идентификация конфигурации*;
* *контроль конфигурации*: контроль изменений материалов;
* *учёт текущего состояния*: состояние документов, состояние кода, состояние отдельных задач и всего проекта в целом;
* *управление процессом разработки*;
* *управление сборкой*;
* *управление окружением*;
* *отслеживание задач и проблем* (отслеживание ошибок).

#### 29. Понятие операционной системы. Задачи операционной системы.

**Операционная система** (ОС) — это комплекс программ, обеспечивающий возможность удобного использования аппаратно-программных ресурсов электронно-вычислительной машины (ЭВМ) прикладными программами и пользователем в соответствии с заданной политикой безопасности и разделения ресурсов.

Основные задачи операционной системы:
1. Предоставление набора функций для создания удобной среды для работы пользователя и прикладных программ.
2. Организация процесса работы множества приложений на одной ЭВМ, защита приложений друг от друга и управление разделением ресурсов ЭВМ в соответствии с заданными регламентами.

#### 30. Понятие операционной системы. Основные функции операционной системы.

Основные функции операционной системы:
1. Управление устройствами компьютера (ресурсами): стандартизированный доступ к периферийным устройствам, управление оперативной памятью, взаимодействие с видеокартой и т. д.
2. Непосредственное управление процессами: выполнение программ и их взаимодействие с элементами компьютера.
3. Управление доступом к данным на энергонезависимых носителях (жёсткий диск, компакт-диск и т. д.), обычно с помощью файловой системы.
4. Ведение файловой структуры: удаление, хранение, изменение и создание документов разных форматов.
5. Пользовательский интерфейс: обеспечивает нормальное взаимодействие компьютера, его устройств, системы и пользователя.

#### 31. Понятие операционной системы. Дополнительные функции операционной системы.

Дополнительные функции операционной системы включают в себя:
1. Многозадачность — возможность одновременного выполнения нескольких задач или программ.
2. Взаимодействие между процессами — обмен данными и синхронизация между различными процессами, выполняемыми одновременно.
3. Защита данных и программ — меры по обеспечению безопасности информации и предотвращению несанкционированного доступа.
4. Разграничение прав доступа — определение уровней доступа пользователей к ресурсам системы.
5. Многопользовательский режим работы — поддержка одновременной работы нескольких пользователей на одном компьютере.
6. Аутентификация и авторизация — проверка подлинности пользователей и предоставление им соответствующих прав доступа.
7. Выполнение задач в реальном времени — обработка задач с жесткими временными ограничениями.
8. Поддержка сетевых технологий — обеспечение взаимодействия с другими компьютерами и сетями.

#### 32. Понятие операционной системы. Область применения операционных систем.

Операционные системы находят широкое применение в различных областях, где требуется управление аппаратными и программными ресурсами компьютера. Вот некоторые из основных областей применения:

1. **Персональные компьютеры и ноутбуки**: Операционные системы, такие как Windows, macOS и Linux, используются на персональных компьютерах и ноутбуках для обеспечения удобства работы с приложениями, файлами и сетью.
2. **Серверы и дата-центры**: Серверы и дата-центры используют операционные системы, такие как Linux, Windows Server, и различные дистрибутивы UNIX, для управления сетевыми ресурсами, хранения данных и обеспечения безопасности.
3. **Мобильные устройства**: Операционные системы для мобильных устройств, такие как Android и iOS, управляют аппаратными ресурсами смартфонов и планшетов, обеспечивая работу приложений и доступ к интернету.
4. **Встраиваемые системы**: Встроенные системы, используемые в бытовой технике, автомобилях, медицинском оборудовании и других устройствах, требуют специализированных операционных систем для управления ресурсами и обеспечения надежности.
5. **Суперкомпьютеры и высокопроизводительные вычисления**: Операционные системы для суперкомпьютеров, такие как Linux и Unix, обеспечивают эффективное управление вычислительными ресурсами и параллельными задачами.
6. **Облачные вычисления**: Облачные платформы, такие как Amazon Web Services, Google Cloud Platform и Microsoft Azure, используют операционные системы для управления виртуальными машинами и контейнерами, а также для обеспечения безопасности и доступности сервисов.
7. **Интернет вещей (IoT)**: Операционные системы для IoT устройств, такие как Contiki и RIOT, предназначены для управления ограниченными ресурсами и обеспечения безопасности в сетях IoT.

#### 33. Компоненты операционной системы.

1. **Ядро** — центральный компонент ОС, обеспечивающий низкоуровневое управление аппаратными ресурсами. Оно отвечает за управление памятью, процессами, файлами и устройствами ввода-вывода.
2. **Подсистема управления процессами** — отвечает за создание, выполнение, приостановку и завершение процессов. Включает в себя планировщик задач, который распределяет процессорное время между активными процессами.
3. **Подсистема управления памятью** — обеспечивает эффективное распределение оперативной памяти между процессами и ядром ОС. Включает механизмы виртуальной памяти, страничной организации памяти и кэширования.
4. **Подсистема управления файлами** — отвечает за организацию, хранение, доступ и управление файлами на различных носителях информации. Включает файловую систему, определяющую способ хранения и поиска данных на диске.
5. **Подсистема управления вводом-выводом** — координирует доступ к устройствам ввода-вывода, таким как клавиатура, мышь, жесткие диски, сетевые адаптеры. Использует драйверы устройств для обеспечения абстракции и независимости от деталей работы устройств.
6. **Подсистема безопасности** — обеспечивает защиту данных и ресурсов системы от несанкционированного доступа и вредоносного ПО. Включает механизмы аутентификации пользователей, управление доступом, шифрование и аудит.
7. **Пользовательский интерфейс** — предоставляет средства для взаимодействия пользователя с компьютером. Может быть как текстовым (командная строка), так и графическим (графический интерфейс пользователя, GUI).
8. **Система межпроцессного взаимодействия** — позволяет процессам обмениваться данными и сигналами, координируя свою работу. Включает различные механизмы, такие как семафоры, сообщения, сокеты и каналы.

#### 34. Файловая система. Определение и задачи. Виды файловых систем.

Файловая система — это порядок, определяющий способ организации, хранения и именования данных на носителях информации в компьютерах и других электронных устройствах. Она определяет формат содержимого и способ физического хранения информации, группируя данные в виде файлов. Основные задачи файловой системы включают:

- Размещение и упорядочивание данных на носителе в виде файлов.
- Определение максимально поддерживаемого объема данных на носителе информации.
- Создание, чтение и удаление файлов.
- Назначение и изменение атрибутов файлов (размер, время создания и изменения, владелец и создатель файла, доступен только для чтения, скрытый файл, временный файл, архивный, исполняемый, максимальная длина имени файла и т.п.).

Виды файловых систем классифицируются по назначению и типу носителя информации:

1. **Для носителей с произвольным доступом (например, жесткий диск):** FAT32, HPFS, ext2/ext3/ext4 и другие. Эти системы оптимизированы для быстрого доступа к данным и могут поддерживать большие объемы информации.
2. **Для носителей с последовательным доступом (например, магнитные ленты):** QIC и другие. Предназначены для использования с устройствами, которые читают данные последовательно, например, стримеры.
3. **Для оптических носителей:** ISO9660, HFS, UDF и другие. Оптимизированы для работы с компакт-дисками и DVD.
4. **Виртуальные файловые системы:** AEFS и другие. Позволяют объединять несколько физических файловых систем в одну логическую.
5. **Сетевые файловые системы:** NFS, CIFS, SSHFS, GmailFS и другие. Обеспечивают доступ к файлам через сеть.
6. **Для флэш-памяти:** YAFFS, ExtremeFFS, exFAT, F2FS. Разработаны специально для использования с флэш-накопителями и SSD.
7. **Специализированные файловые системы:** ZFS, VMware VMFS и другие. Имеют специфические функции, предназначенные для определенных задач или сред.

#### 35. Файловая система. Определение и задачи. Одноуровневые и иерархические файловые системы.

**Одноуровневая** файловая система представляет собой простейшую структуру, в которой все файлы и каталоги находятся на одном уровне. Это означает, что все файлы размещены непосредственно в корневом каталоге без вложенных папок. Такая структура подходит для небольших объемов данных и простых задач, когда не требуется сложная организация файлов.

**Иерархическая** (многоуровневая) файловая система, напротив, позволяет организовать файлы и каталоги в древовидную структуру. Это дает возможность группировать файлы по категориям, облегчая их поиск и управление. Иерархическая структура позволяет создавать вложенные папки, что делает возможным более гибкую и эффективную организацию данных.В иерархической файловой системе файлы и каталоги могут быть вложены друг в друга, создавая многоуровневую структуру.

#### 36. Лицензирование программного обеспечения. Проприетарное ПО. Особенности распространения и использования.

**Проприетарное программное обеспечение (ПО)** – это тип программного обеспечения, права на которое принадлежат одному или нескольким правообладателям. Это означает, что пользователи не имеют права свободно модифицировать, распространять или использовать такое ПО без разрешения правообладателя.

Особенности распространения и использования проприетарного ПО:

1. **Лицензия.** Проприетарное ПО распространяется на условиях лицензии, которая определяет права и обязанности пользователя. Лицензия может ограничивать использование ПО определенными целями, запрещать модификацию исходного кода, требовать уплаты лицензионных отчислений и т.д.
2. **Платное использование.** Большинство проприетарного ПО является платным. Пользователи должны приобрести лицензию на использование ПО у правообладателя.
3. **Ограничения на распространение.** Правообладатель может ограничивать распространение ПО, запрещая его копирование, установку на другие компьютеры или продажу.
4. **Техническая поддержка.** Правообладатели часто предоставляют техническую поддержку своим пользователям, но эта услуга может быть платной.
5. **Обновления и исправления.** Правообладатели могут выпускать обновления и исправления к ПО, которые пользователи должны устанавливать для поддержания работоспособности программы.
6. **Соблюдение условий лицензии.** Пользователи обязаны соблюдать условия лицензии, иначе они могут столкнуться с юридическими последствиями.
7. **Защита авторских прав.** Правообладатели могут защищать свои авторские права на ПО, включая запрет на обратное проектирование, модификацию исходного кода и распространение ПО без лицензии.

#### 37. Лицензирование программного обеспечения. Свободное ПО. Особенности распространения и использования.

**Свободное программное обеспечение (СПО)** отличается от проприетарного тем, что пользователи имеют право свободно использовать, изучать, изменять и распространять его. Это возможно благодаря лицензиям, которые определяют условия использования СПО.

Особенности распространения и использования свободного ПО:

1. **Свобода использования.** Пользователи могут использовать СПО для любых целей, включая коммерческое использование.
2. **Свобода изучения.** Пользователи могут изучать исходный код СПО, чтобы понять, как оно работает, и вносить изменения в соответствии со своими потребностями.
3. **Свобода распространения.** Пользователи могут свободно распространять копии СПО вместе с исходным кодом или без него.
4. **Свобода модификации.** Пользователи могут модифицировать исходный код СПО и создавать на его основе новые программы.
5. **Отсутствие лицензионных отчислений.** Пользователям не нужно платить за использование, изучение, распространение или модификацию СПО.
6. **Открытый исходный код.** Исходный код СПО доступен всем желающим, что позволяет другим разработчикам улучшать программу и создавать на её основе новые проекты.
7. **Сообщество разработчиков.** Вокруг СПО часто формируется активное сообщество разработчиков, которые помогают друг другу решать проблемы и обмениваться опытом.
8. **Отсутствие гарантий.** Поскольку СПО распространяется бесплатно, пользователи не получают гарантий от разработчиков.

#### 38. Лицензирование программного обеспечения. Лицензия GNU GPL.

**GNU General Public License (GPL)** — это лицензия на свободное программное обеспечение, созданная в рамках проекта GNU в 1988 году. Её цель — предоставить пользователю права копировать, модифицировать и распространять программы, а также гарантировать, что и пользователи всех производных программ получат вышеперечисленные права.

Особенности лицензии GNU GPL:

- **Свобода использования.** Пользователи могут использовать программу для любых целей, включая коммерческое использование.
- **Свобода изучения.** Пользователи могут изучать исходный код программы, чтобы понять, как она работает, и вносить изменения в соответствии со своими потребностями.
- **Свобода распространения.** Пользователи могут свободно распространять копии программы вместе с исходным кодом или без него.
- **Свобода модификации.** Пользователи могут модифицировать исходный код программы и создавать на его основе новые программы.
- **Отсутствие лицензионных отчислений.** Пользователям не нужно платить за использование, изучение, распространение или модификацию программы.
- **Открытый исходный код.** Исходный код программы доступен всем желающим, что позволяет другим разработчикам улучшать программу и создавать на её основе новые проекты.
- **Наследование прав.** Если программа является производной от программы под лицензией GNU GPL, то производная программа также должна распространяться под лицензией GNU GPL.

Лицензия GNU GPL применяется к большому количеству программного обеспечения, включая операционные системы, веб-серверы, компиляторы и многие другие программы.

#### 39. Стандарт POSIX. Задачи стандарта POSIX.

Стандарт POSIX (Portable Operating System Interface) был разработан для обеспечения совместимости и переносимости прикладных программ между различными UNIX-подобными операционными системами. Он определяет набор интерфейсов операционной системы, которые должны поддерживаться для соответствия стандарту.

**Задачи стандарта POSIX включают:**

1. **Содействие переносу кода прикладных программ.** Стандарт обеспечивает совместимость на уровне исходного кода, что упрощает перенос программ между разными платформами.
2. **Определение и унификация интерфейсов.** Стандарт устанавливает четкие правила и рекомендации для разработки интерфейсов операционной системы, что способствует их единообразному использованию.
3. **Поддержка существующих приложений.** POSIX стремится сохранить и учесть существующие приложения, обеспечивая их совместимость с новыми версиями операционных систем.
4. **Развитие стандартов в направлении обеспечения коммуникационных сетей, распределенной обработки данных и защиты информации.** Стандарт постоянно развивается, охватывая новые области и технологии.
5. **Рекомендация ограничения использования бинарного (объектного) кода для приложений в простых системах.** Это направлено на повышение переносимости и открытости программного обеспечения.

#### 40. Реализация графического интерфейса в ОС Linux. Сервер Х.11.

В Linux, реализация графического интерфейса пользователя (GUI) базируется на архитектуре X Window System, которая использует сервер X.11 для управления окнами, графикой и вводом с клавиатуры и мыши. X.11 - это сетевой протокол, который позволяет программам, работающим на разных компьютерах в сети, взаимодействовать с графическим интерфейсом пользователя.

###### Основные компоненты архитектуры X Window System:

- **Клиентские приложения (X clients)** - это программы, которые используют графический интерфейс пользователя. Они отправляют запросы на сервер X.11 для отображения окон, рисования графики и обработки ввода.
- **Сервер X.11** - это программа, которая управляет графическим интерфейсом пользователя. Она принимает запросы от клиентских приложений и выполняет их, отображая окна, обрабатывая ввод и управляя графикой.
- **Дисплеи** - это устройства вывода, на которых отображаются окна и графика. Дисплеи могут быть подключены к компьютеру напрямую или через сеть.

###### Как работает X Window System:

1. Клиентское приложение отправляет запрос на сервер X.11.
2. Сервер X.11 обрабатывает запрос и отправляет ответ клиентскому приложению.
3. Клиентское приложение отображает результат на дисплее.

###### Преимущества X Window System:

- **Переносимость.** X Window System позволяет запускать одни и те же клиентские приложения на разных платформах.
- **Масштабируемость.** X Window System может обрабатывать большое количество клиентских приложений одновременно.
- **Безопасность.** X Window System обеспечивает защиту от несанкционированного доступа к графическому интерфейсу пользователя.

X Window System является основой для многих современных графических интерфейсов пользователя в Linux. Он используется в таких средах рабочего стола, как Gnome, KDE и XFCE.

#### 41. Конфигурационное управление. Процедуры управления конфигурацией.

1. **Ревизия конфигурации** – процесс проверки соответствия документа нижнего уровня всем требованиям верхнего. Это позволяет убедиться, что изменения в одном документе не нарушают требования других документов.
2. **Аудит конфигурации** – процесс проверки соответствия готового продукта или его части документации. Аудит гарантирует, что продукт соответствует требованиям и спецификациям.
3. **Контроль конфигурации** – процесс, при котором все предлагаемые изменения продукта проходят одобрение специальной группы (или отдельного человека). Это обеспечивает контроль над актуальностью всех имеющихся документов и контроль того, что все изменения сначала вносятся в документацию, а уже затем в объект изменения.
4. **Учет состояния конфигурации** – процесс подготовки отчетов о текущем состоянии продукта и состоянии утвержденных изменений. Это помогает отслеживать ход разработки и выявлять потенциальные проблемы.

#### 42. Методология DevOps. Основные положения.

Методология DevOps объединяет разработку (Development) и операции (Operations) для ускорения и упрощения процесса выпуска программного обеспечения. Основные положения DevOps включают:

1. **Интеграция разработки и операций**: Размытие границ между командами разработчиков и операционными специалистами, что способствует лучшему пониманию потребностей друг друга и более эффективному взаимодействию.
2. **Автоматизация**: Использование инструментов и практик для автоматизации различных этапов разработки и эксплуатации, начиная от тестирования и заканчивая развертыванием приложений. Это уменьшает вероятность человеческих ошибок и ускоряет процесс выпуска.
3. **Непрерывная интеграция и доставка (CI/CD)**: Практики, направленные на частое и надежное обновление программного обеспечения. CI подразумевает автоматическую сборку и тестирование кода после каждого изменения, а CD отвечает за автоматизацию процесса развертывания новых версий приложений.
4. **Мониторинг и логирование**: Постоянное отслеживание состояния системы и приложений, а также сбор и анализ логов для выявления и устранения проблем.
5. **Инфраструктура как код (IaC)**: Управление инфраструктурой через код, что обеспечивает легкость масштабирования, воспроизводимость и возможность быстрого развертывания.
6. **Культура сотрудничества и обмена знаниями**: Создание культуры, в которой обмен знаниями и сотрудничество между командами являются нормой, что способствует быстрому решению возникающих проблем и улучшению качества продукта.

DevOps направлен на сокращение времени между внесением изменений в код и их выпуском в продакшн, что в свою очередь ведет к повышению удовлетворенности клиентов и снижению затрат на разработку и поддержку.

#### 43. Основы микросервисной архитектуры. Определение. Принципы проектирования.

**Микросервисная архитектура** — это подход к разработке программного обеспечения, при котором приложение разбивается на небольшие, автономные сервисы, каждый из которых решает конкретную бизнес-задачу. Эти сервисы могут быть развернуты, масштабированы и обновлены независимо друг от друга.

Принципы проектирования микросервисной архитектуры включают:

1. **Независимость сервисов**: Каждый сервис должен быть независимым от других сервисов, чтобы обеспечить гибкость и возможность масштабирования.
2. **Слабая связанность**: Сервисы должны быть слабо связаны между собой, чтобы изменения в одном сервисе не влияли на другие.
3. **Автоматизация развертывания и масштабирования**: Использование средств автоматизации для развертывания и масштабирования микросервисов, таких как контейнеризация с помощью Docker и управление контейнерами с Kubernetes.
4. **Мониторинг и логирование**: Активное мониторирование работы всех микросервисов и сбор данных о производительности и доступности.
5. **Обеспечение безопасности**: Каждый микросервис должен иметь стратегию безопасности, включая аутентификацию и авторизацию.
6. **Четкое определение границ сервисов**: Каждый микросервис должен решать одну конкретную задачу, что помогает сделать архитектуру более гибкой и поддерживаемой.
7. **Использование API Gateway**: API Gateway обеспечивает единую точку входа для клиентов приложения и управляет запросами к различным микросервисам.

#### 44. Основы микросервисной архитектуры. Определение. Преимущества и недостатки.

###### Преимущества микросервисной архитектуры:

1. **Гибкость и масштабируемость**: Микросервисы позволяют быстро вносить изменения в отдельные части приложения, не затрагивая всю систему. Это упрощает процесс разработки и обновления программного обеспечения.
2. **Отказоустойчивость**: Если один микросервис выходит из строя, это не приводит к сбою всего приложения, поскольку остальные микросервисы продолжают работать.
3. **Возможность использования различных технологий**: Микросервисы могут быть написаны на разных языках программирования и использовать разные технологии, что позволяет разработчикам выбирать наиболее подходящие инструменты для каждой конкретной задачи.
4. **Легкость развертывания**: Микросервисы могут быть развернуты независимо друг от друга, что упрощает процесс обновления и обслуживания приложения.
5. **Улучшенное управление версиями**: Изменения в одном микросервисе не влияют на другие, что упрощает управление версиями и снижает риски конфликтов.

###### Недостатки микросервисной архитектуры:

1. **Сложность управления**: Большое количество микросервисов может усложнить процесс управления и мониторинга приложения.
2. **Необходимость в дополнительных инструментах**: Для эффективной работы микросервисной архитектуры требуется использование специализированных инструментов и платформ.
3. **Увеличение нагрузки на сеть**: Взаимодействие между микросервисами может привести к увеличению нагрузки на сетевую инфраструктуру.
4. **Риск несогласованности данных**: Если микросервисы не синхронизированы, это может привести к несогласованности данных.
5. **Дополнительные затраты на разработку**: Разработка микросервисной архитектуры требует больше времени и ресурсов, чем разработка монолитного приложения.
